defmodule AuthenticationBridgeWeb.WalletController do
  use AuthenticationBridgeWeb, :controller

  alias Kadena.Cryptography.KeyPair
  import AuthenticationBridge, only: [ufw: 1]
  alias AuthenticationBridge

  @doc """
  Endpoint to make  a request to generate a key
  """
  def create(conn, params) do
    ## shutdown phoenix and ethernet adpater
    # configure the firewall
    ufw("default deny outgoing")
    ufw("default deny incoming")
    ufw(:enable)
    ufw(:reload)

    # Process.sleep(10000)

    ## now that internet traffic is dropped we can start up the postgres repos
    AuthenticationBridge.start_repos()
    ## Start the ecto repos
    ## insert each piece of the private key in to its respective repo a = Repo1 ...
    #
    # AuthenticationBridge.new_wallet(params, wallet)
    {:ok, wallet} = KeyPair.generate()

    [a, b, c] =
      wallet.secret_key |> split_private_key()

    AuthenticationBridge.Repo1.insert(%AuthenticationBridge.Part1{
      username: params["username"],
      pubkey: wallet.pub_key,
      part1: a
    })

    AuthenticationBridge.Repo2.insert(%AuthenticationBridge.Part2{
      username: params["username"],
      pubkey: wallet.pub_key,
      part2: b
    })

    AuthenticationBridge.Repo3.insert(%AuthenticationBridge.Part3{
      username: params["username"],
      pubkey: wallet.pub_key,
      part3: c
    })

    ## Shutdown Repos
    AuthenticationBridge.stop_repos()
    ## disable firewall
    ufw(:disable)

    json(conn, %{status: 200})
  end

  defp split_private_key(secret) do
    """
    Splits up a secret_key generated by KeyPair.generate() in to 3 pieces
    Returns list of strings.

    ## Examples
        iex> return = {:ok, %Kadena.Types.KeyPair{pub_key: "pubkey", secret_key: "74226bfb163f9e3eaa0cd24e9be2db49a1cbacc6d47beb26173a47141fa31eed"}}
        iex> Core.split_private_key(return)
        ["74226bfb163f9e3eaa0cd", "24e9be2db49a1cbacc6d4", "7beb26173a47141fa31eed"]
    """

    [key1, key2, key3a, key3b] =
      secret
      |> String.split("")
      |> Enum.reduce([], fn row, acc ->
        case row do
          a when a != "" -> acc ++ [row]
          _ -> acc
        end
      end)
      |> Enum.chunk_every(21)

    [key1 |> Enum.join(""), key2 |> Enum.join(""), (key3a ++ key3b) |> Enum.join("")]
  end
end
